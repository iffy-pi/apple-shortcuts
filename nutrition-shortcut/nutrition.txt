'''
TODO:
- Update saving to backlog
- Revamp log algorithm to work with dictionaries!

DONE:
- Made new storage format for backlog
Backlog will be managed as a JSON formatted list:
{
	content: [
			{
				Date: '...',
				Food: ...
			},
			...
		]
}
saved to STORE/Other/backlog.json


INFO:
Current file structure (FLS):
- Presets
	- presetNames.txt
	- Foods
		- ...
- Other
	- backlog.txt and backtag.txt => backlog.json

'''


def NutriDixUpdater():
	pass


# UPDATER
def WeekSummary():
	pass

# HISTORY

def FoodHistory():
	pass

# BARCODES ------------

def BarcodeSearch():
	pass

def GetBarcode():
	pass

def EditBarcode():
	pass

def RemoveBarcode():
	pass


# PRESETS -----------------
def RemovePreset():
	pass

def GetPreset(): # Get Preset
	pass

def MakePreset(): # Make Preset
	pass

def EditPreset(): # Edit Preset
	pass

def RemovePreset():
	pass

# MISC -----------------------------

def BulkEntry(): # Bulk Entry
	pass

def FoodsList(): # Foods List
	pass

def GetRecent(): # "Get Recent"
	pass

# SHARED -------------

def LogAlgorithm(dix): # Log Algorithm
	'''
	Update to use new backlog system
	Update to use dictionary from input
	{
		'Date':..
		'Food':...
	}
	'''
	pass

def DisplayFoodItem():
	pass

def SearchAlgorithm():
	pass

def NutriDix():
	return ;;


# GLOBAL VARS
STORE = "Shortcuts/FLS"

def Nutrition():

	TRUE = 1
	FALSE = 0

	checkForUpdates = TRUE
	# user manually wants to clear backlog 
	reqBacklogClear = FALSE

	result = run("NutriDix")
	NutriDic = Dictionary(result)

	DVal = NutriDic['Total Energy Today']

	deviceModel = GetDeviceDetails("Model")
	if deviceModel != 'iPhone':
		clearBacklog = FALSE
		text = f"Foods logged on {deviceModel} will be added to backlog"

	else:
		healthSamples = HealthApp.Find(
				AllHealthSamples,
				whereAllAreTrue=[
					Type="Dietary Energy",
					StartDate=Today,
				],
				Unit=cal
			)

		unit = Health.Sample.GetDetails(healthSamples[0], "Unit")

		REPEATRESULTS = []
		for sample in healthSamples:
			# this is done in shortcuts by just getting the value at the end of repeat
			# it automatically aggregates repeat results
			REPEATRESULTS.append(Health.Sample.GetDetails(sample, "Value"))


		Ks = Round( Sum(REPEATRESULTS), "hundredths")

		if Count("Items", Ks) < 1:
			Ks = 0

		IFRESULT = f"You've eaten {Ks} Calories Today."

	Prompt = IFRESULT

	mainMenu = Menu(prompt=prompt, options=[
			"Quick Log",
			"Log Foods",
			"Log Foods In Bulk",
			"Search and View",
			"Presets",
			"Barcodes",
			"Recent Meals",
			"Weekly Summary",
			"Food History",
			"Clear Backlog",
		])

	if mainMenu.opt("Quick Log"):
		# quick log so dont check for updates
		checkForUpdates = FALSE

		# InRecents does not exist!
		for item in run("Get Recent", input=InRecents):
			CurFood = item
			text = f"How many servings of {CurFood['Name']}\n(1 serving = {CurFood['Serving Size']})"
			
			# translates to set dictionary value in CurFood and then set dictionary
			CurFood['Servings'] = AskForInput(text, Input.Number, default=1, allowDecimalNumbers=True, allowNegativeNumbers=True)

			dix = {
				'Date': str(Date.CurrentDate)
				'Food': dix(CurFood)
			}
			LogList.append(dix)

		for item in LogList:
			run("Log Algorithm", input=item)

	elif mainMenu.opt("Log Foods"):
		if GetDeviceDetails("Model") == 'iPhone':
			# action will be discontinued in later versions
			ContinueInShortcutsApp()

		LoggedFoodsDix = {
			'SAMPLE' : 'SAMPLE'
		}

		Dating = AskForInput("What date and time? Click Done for Right Now", Input.DateAndTime)


		for item in run("Foods List"):
			CurFood = item
			dix = {
				'Date': str(Dating)
				'Food': dix(CurFood)
			}

			CurLoggedFood = run("Log Algorithm", input=dix)
			
			# Comment: Get the logged food dictionary and add it into the logged foods dix,
			# with key: servings of food and value: food dictionary

			roundedNumber = Round(Number(CurLoggedFood['Servings']), "Hundredths")
			LoggedFoodsDix[ f"{roundedNumber}x{CurLoggedFood['name']}" ] = CurLoggedFood


		makePresetMenu = Menu(prompt="Make Preset?", options=["Yes", "No"])

		if makePresetMenu.opt("Yes"):
			# Get the keys from the logged foods dix so users can select what foods they want to make into a preset
			res = Filter( 
				SplitText(Text(LoggedFoodsDix.Keys)), 
				where=[
					"Name" is not "SAMPLE",
				])

			chosenItems = ChooseFrom(res, prompt="Select Foods For Preset", selectMultiple=True)

			for item in chosenItems:
				# With each chosen key we use the key to retrieve the value from logged food dix
				# and add it to the list of foods to be made into a preset (chosenFoods)
				# each item in this case are the keys from the loggedfoodsdix
				ChosenFoods.Append( LoggedFoodsDix[item] )

			# run make preset with chosen foods
			run("Make Preset", input=ChosenFoods)

		elif makePresetMenu.opt("No"):
			pass

	elif mainMenu.opt("Log Foods In Bulk"):
		if GetDeviceDetails("Model") == 'iPhone':
			# action will be discontinued in later versions
			ContinueInShortcutsApp()

		run("Bulk Entry")

	elif mainMenu.opt("Search and View"):
		# run search algorithm and display food with 

		searchResult = run("Display Food Item", input=run("Search Algorithm"))

		postSearchMenu = Menu(["Log Entry", "Make Preset", "Exit"])

		if postSearchMenu.opt("Log Entry"):
			date = AskForInput("Date:", Input.DateAndTime, default=Date.CurrentDate)

			dix = {
				'Date': str(date)
				'Food': dix(searchResult)
			}
			res = run(
				"Log Algorithm",
				input=dix)

			LoggedFoods2 = res

			svp = Menu(["Yes", "No"], prompt="Save As Preset?")

			if svp.opt("Yes"):
				RunShorctut("Make Preset", input=LoggedFoods2)
			if svp.opt("No"):
				pass

		elif postSearchMenu.opt("Make Preset"):
			run("Make Preset", input=searchResult)

		elif postSearchMenu.opt("Exit"):
			pass

	elif mainMenu.opt("Presets"):

		prm = Menu(prompt="Presets", options=["View Presets", "Make Preset", "Edit Preset", "Remove Preset(s)"])

		if prm.opt("View Presets"):
			res = run("Get Preset")
			for repeatItem in res:
				run("Display Food Item", input=repeatItem)

		elif prm.opt("Make Preset"):
			# run foods list to get list of foods to be made into a preset
			res = run("Foods List")

			for item in res:
				curFood = item
				loggedFoods3.append(curFood)

			run("Make Preset", loggedFoods3)


		elif prm.opt("Edit Preset"):
			run("Edit Preset")


		elif prm.opt("Remove Preset(s)"):
			# retrieve preset names, let user choose preset then retrieve food dix and delete it by running remove preset
			file = GetFile(f"{STORE}/Presets/presetNames.txt")
			res = SplitText(file, SplitText.ByNewLines)
			
			presetsToBeDeleted = ChooseFrom(res, selectMultiple=True)

			ShowAlert("Do You Want To Continue?", title="Presets About to Be Deleted", showCancel=True)

			for item in presetsToBeDeleted:
				file = GetFile(f"{STORE}/Presets/Foods/{item}.txt")
				text = file.read()
				run("Remove Preset", text)

	elif mainMenu.opt("Barcodes"):
		brm = Menu(prompt="Barcodes", options=[
			"View Personal Database",
			"Add to Personal Database",
			"Edit Items in Personal Database",
			"Remove From Personal Database"
			])


		if brm.opt("View Personal Database"):
			res = run("Get Barcode")
			for item in res:
				run("Display Food Item", input=item)

		elif brm.opt("Add to Personal Database"):
			run("Barcode Search")

		elif brm.opt("Edit Items in Personal Database"):
			run("Edit Barcode")

		elif brm.opt("Remove From Personal Database"):
			res = run("Get Barcode")
			run("Remove Barcode", input=res)
		

	elif mainMenu.opt("Recent Meals"):
		res = run("Get Recent")
		for item in res:
			run("Display Food Item", input=item)


	elif mainMenu.opt("Weekly Summary"):
		run("Week Summary")


	elif mainMenu.opt("Food History"):
		file = GetFile(f"{STORE}/Other/backtag.txt")
		if file is not None:
			res = run("Get Barcode")
			for item in res:
				run("Display Food Item", input=item)

		run("Food History")

	elif mainMenu.opt("Clear Backlog"):
		reqBacklogClear = TRUE


	# clearing the backlog
	if GetDeviceDetails("Device Model") == "iPhone":
		# check if the backlog has any files
		res = Dictionary(GetFile(f"{STORE}/Other/backlog.json"))
		backlog = res['content']

		if Count(backlog) > 0:
			# clear items by logging them
			for item in backlog:
				run("Log Algorithm", input=item)

			# erase the backlog
			text = "{ 'content': [] }"
			SaveFile(text, path=f"{STORE}/Other/backlog.json")

		else:
			# nothing to clear
			if reqBacklogClear == TRUE:
				# if user req clear backlog let them no there was nothing to clear
				ShowAlert("There are no foods in the backlog")

	if checkForUpdates == TRUE:
		run("NutriDix Updater")




