'''
ON THE TODO:
    - Shortcut Review
        - Search Algorithm next! performance is not giving
        - Do the rest

    - Refactor NutriDix updater for the new update process
    - # Regex for illegal characters, use when saving to file [\*\/\\><\.":\?\|]

UDPATES AND CHANGES:
- File/Strucutral Changes:
    - JSON Everything
        - All "*dix.txt" files are now converted to JSON,
        - This includes Food files, and any other relevant dictionaries
        - Done with port over to JSON

    - New backlogging:
        - Backlog is now stored in new format at FLS/Other/backlog.json
        - Backlog is managed in Nutrition function as usual, but is now deleted when it is empty
        - Log algorithm puts stuff in the backlog
        - Storage format:
            {
                backlog: [
                        {
                            Date: '...',
                            Food: ...,
                        },
                        ...
                    ]
            }

    - History Cache
        - Improve logging speeds by adding a history cache
        - Log Algorithm shortcut puts things in cache, and main shortcut clears it at end of execution
        - Makes sure that large size of history file does not slow logging process down
        - History Cache is saved to FLS/History/foodHistoryCache.json,
        - Format:
            {
                cache : [
                    food: ...,
                    servings: ...,
                    cals: ...,
                    date: ...,
                    time: ...,
                ]
            }

    - Refactored Food History
        - Food history is revamped from FLS/History/foodHistoryDix.txt => FLS/History/foodHistory.json
        - Has new format, see PortOverFoodHistory
        - Used in the main shortcut when clearing cache

    - Environment Variables
        - JSON dictionary stored in FLS/Other/env.json
        - Is formatted:
            {
                '<env var name>' : '<env var value>'
            }
        - Used to contain flags or values that we would like to share between shortcuts:
            - Share hasHealthApp between Nutrition and Log Algorithm

- Shortcut Changes
    - Added Shortcuts
        - Save Env Vars
            - Saves environment variables for a given shortcut run so that other shortcuts can access it easily
            - See environment variables above.
        
        - Port Over Food History
            - Converts old foodHistoryDix.txt format to foodHistory.json

        - Port Over Foods
            - Updates food files to JSON
            - Adds a unique ID so they can be identified

        - Generate Food ID
            - Generates a unique id for each food object

    - Removed Shortcuts
        - Get History On

    - Updated Shortcuts
        - Nutrition
            - Improved methods to check when a device has a health app.
            - Improved backlog clearing
            - Added history cache clearing

        - Log Algorithm
            - Improved logging speeds by minor refactoring of code
            - Implemented history caching using new history cache files

        - Food History
            - Refactored to handle new food history format
            - Other improvements are under the hood


CURRENT STATE:
    - Current file structure (FLS):
        - Presets
            - presetNames.txt : For names of presets
            - Foods
                - Food.txt dictionaries ...

        - Recents:
            - recentNames.txt : For names of recents foods
            - Foods:
                - Food.txt dictionaries ...

        - Barcodes
            - barcodeDix.txt : Maps barcodes to food names
            - Foods
                - Food.txt dictionaries ...
        
        - History
            - foodHistoryDix.txt => foodHistory.json
            - foodHistoryCache.json

        - Other
            - backlog.txt and backtag.txt => backlog.json
            - env.json
            - shortcutDix.txt : ?Maps in script shortcut names to the actual shortcut names
                {
                    "Edit Preset":"Edit Preset2.0",
                    "Correct Dictionary":"Correct Dictionary",
                    "Food History":"Food History",
                    "Foods List":"Foods List 1.3",
                    "Bulk Entry":"Bulk Entry",
                    "Plot Week Summary":"Plot Week Summary",
                    "Log Algorithm":"Log Algorithm",
                    "Edit Barcode":"Edit Barcode",
                    "Day Summary":"Day Summary",
                    "Get Barcode":"Get Barcode",
                    "NutrDix":"NutrDix",
                    "Remove Barcode":"Remove Barcode",
                    "Plot Day Summary":"Plot Day Summary",
                    "Remove Preset":"Remove Preset2.0",
                    "NutrDix Updater":"Nutri-Hub",
                    "Barcode Search":"Barcode Search",
                    "Number Converter":"Number Converter",
                    "Manual Logging":"Manual Logging 3",
                    "Make Food Item":"Make Food Item",
                    "Nutrition":"Nutrition",
                    "Get Preset":"Get Preset",
                    "Get Recent":"Get Recent",
                    "Add Recents":"Add Recents",
                    "Week Summary":"Week Summary",
                    "Search Algorithm":"Search Algorithm",
                    "Display Food Item":"Display Food Item 1.2",
                    "Add Preset":"Add Preset 1.1",
                    "Make Preset":"Make Preset 2.2",
                    "Save Env Vars": "Save Env Vars",
                    "Port Over Food History": "Port Over Food History",
                    "Port Over Foods": "Port Over Foods",
                    "GFID": "Generate Food ID"
                }
            - shortcutLinksDix.txt : ? Maps shortcuts to their icloud links
            - Search
'''

# GLOBAL VARS
FLS = "Shortcuts/FLS"

#---------------------------------------------------------------------------------------------------------------------------------
# TO USE #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------
def ConvertTextFileToJSON():
    GetFile(f"{folder}/{filename}.txt")
    RenameFile(f"{filename}.json")

def GenFoodId():
    file = GetFile(f"{FLS}/Other/nextFoodId.txt")
    if file is not None:
        IFRESULT = file
    else:
        IFRESULT = "0"
    
    _id = Number(IFRESULT)
    num = _id + 1
    SaveFile(num, f"{FLS}/Other/nextFoodId.txt")
    return 



def PortOverFoods():

    file = GetFile(f"{FLS}/Other/nextFoodId.txt")
    if file is not None:
        IFRESULT = file
    else:
        IFRESULT = "0"
    nextId = Number(IFRESULT)

    foodLocs = [
        f"{FLS}/Recents/Foods",
        f"{FLS}/Presets/Foods"
        f"{FLS}/Barcodes/Foods"
    ]

    for loc in foodLocs:
        dirr = GetFile(f"{loc}", errorIfNotFound=False)
        for item in GetContentsOfFolder(dirr):
            food = Dictionary(item)
            food['id'] = nextId
            nextId  = nextId + 1

            # save the new food file
            SaveFile(food, f"{loc}/{food['Name']}.json")

            file = GetFile(f"{loc}/{food['Name']}.txt", errorIfNotFound=False)
            if file is not None:
                DeleteFile(file, deleteImmediately=True)

    SaveFile(nextId, f"{FLS}/Other/nextFoodId.txt", overwrite=True)



#---------------------------------------------------------------------------------------------------------------------------------
# UPDATER #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------
def NutriDixUpdater():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
# WEEK SUMMARY #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------
def WeekSummary():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
# HISTORY #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------

def FoodHistory():
    TRUE = 1
    FALSE = 0

    # used for logs between certain days
    useDateList = FALSE

    file = GetFile(f"{FLS}/History/foodHistory.json")
    if file is not None:
        IFRESULT = file
    else:
        IFRESULT = {}

    history = Dictionary(IFRESULT)

    # show foods today in main menu
    today = CurrentDate()

    dayDix = history[ today.format(date="short", time=None) ]
    if dayDix is not None:
        keys = FilterFiles(dayDix[keys], sortBy="Name", AtoZ=True)
        for timeKey in keys:
            timeList = dayDix[timeKey]
            for logItem in timeList:
                text = f'''{timeKey}: {logItem['servings']}x {logItem['food']} ({logItem['cals']} kCals)'''
                todaysLogs.append(text)


    if Count(todaysLogs) > 0:
        IFRESULT = f'''
            Foods eaten today:
            {todaysLogs}
        '''
    else:
        IFRESULT = 'You have not eaten any foods today'

    prompt = IFRESULT

    mainMenu = Menu(prompt=prompt, ['More History Options', 'Exit'])
    if mainMenu.opt("More History Options"):
        subMenu = Menu(prompt="History Options", [
                'Foods Logged On Day',
                'Foods Logged Between...',
                'Foods Logged In Past Week',
                'Foods Logged In Past Month',
                'Foods Logged All Time',
                'Exit'
            ])

        if subMenu.opt('Foods Logged On Day'):
            start = AskForInput(Input.Date)
            end = AddToDate(start, days=1)

        elif subMenu.opt('Foods Logged Between...'):
            start = AskForInput(Input.Date)
            end = AddToDate(AskForInput(Input.Date), days=1)

        elif subMenu.opt('Foods Logged In Past Week'):
            start = SubFromDate(today, weeks=1)
            end = AddToDate(today, days=1)

        elif subMenu.opt('Foods Logged In Past Month'):
            start = SubFromDate(today, months=1)
            end = AddToDate(today, days=1)

        elif subMenu.opt('Foods Logged All Time'):
            useDateList = TRUE
            # go through all the keys
            # reverse because we want the latest ones first
            dateList = filter(history.keys(), sortBy=(Name, ZtoA))

        if subMenu.opt('Exit'):
            return

        if useDateList == TRUE
            IFRESULT = Count(dateList)
        else:
            IFRESULT = TimeBetweenDates(start, end, inDays=True)
        repeats = IFRESULT


        for repeatIndex in range( repeats ):
            if useDateList == TRUE
                IFRESULT = dateList.getItemAtIndex(repeatIndex)
            else:
                # shortcuts are one indexes, so subtract by 1 and add to start
                # doing it so we get latest date first
                res = repeats - repeatndex
                res = AddToDate(start, res)
                IFRESULT = text(res.format(date="short", time=None))

            dayKey = IFRESULT
            dayDix = history[dayKey] 

            if dayDix is not None:
                resultsForDay = []
                keys = filter(dayDix.keys(), sortBy=(Name, ZtoA))

                text = Date(f'{timeKey}h').format(custom="h:mm a")
                dispTime = text

                for timeKey in keys:
                    for log in dayDix[timeKey]:
                        resultsForDay.append( 
                            f'{logItem['servings']}x {logItem['food']} ({logItem['cals']} kCals) @ {dispTime}'
                        )
                logResults.append(f'''
                        {dayKey}
                        {resultsForDay}
                    ''')

        # show results of the search
        text = f"{logResults}"
        text = SetName(text, "Query Results")
        QuickLook(text)

    elif mainMenu.opt("Exit"):
        return



#---------------------------------------------------------------------------------------------------------------------------------

def AddToFoodHistory():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
def PortOverFoodHistory():

    '''
    New Food history format:
    {
        'YYYY-MM-DD': {
            'HH-MM': [{
                'food': ...,
                'servings': ...,
                'cals': ...,
            },
            ...
            ...
            ],
            
            # can either be dictionary if only one item or list of dictionaries if more
        }
    }
    
    For: "1x Fried egg (90.16 kCal"
    ([0-9][0-9]*[\.]*[0-9]*)x (.*) \(([0-9][0-9]*[\.]*[0-9]*) kCal\)
    
    For "1 [Chicken Noodles Super Pack (430 Kcal)]"
    ([0-9][0-9]*[\.]*[0-9]*) \[(.*) \(([0-9][0-9]*[\.]*[0-9]*) Kcal\)\]
    '''

    newHistory = Dictionary();
    history = Dictionary(GetFile(f"{FLS}/History/foodHistoryDix.txt"))

    regex1 = text("([0-9][0-9]*[\.]*[0-9]*)x (.*) \(([0-9][0-9]*[\.]*[0-9]*) [kK][cC]al\)")
    regex2 = text("([0-9][0-9]*[\.]*[0-9]*) \[(.*) \(([0-9][0-9]*[\.]*[0-9]*) [kK][cC]al\)\]")

    for repeatItem in history.keys():
        dayKey = repeatItem
        text = history[dayKey]
        dayDix = Dictionary(text)
        newDayDix = newHistory[dayKey]

        if newDayDix is None:
            newDayDix = Dictionary()
        
        for repeatItem2 in dayDix.keys().filter( name => name != "SAMPLE"):
            timeKey = repeatItem2
            logText = dayDix[timeKey]
            newTimeList = newDayDix[timeKey]

            # if it does not have any value, we will add it to the variable

            for log in logText.splitByNewLines():
                logGroup = []

                # 0 -> servings
                # 1 -> food name
                # 2 -> calories

                # try the first regex
                logGroup = GetAllGroups( MatchText(log, regex1) )
                if Count(logGroup) == 0:
                    # try the other regex
                    logGroup = GetAllGroups( MatchText(log, regex2) )
                    if Count(logGroup) == 0:
                        logGroup = [1, log, 0]

                totalCals = RoundNumber(logGroup[2])
                servings = Number(logGroup[0])

                dix = {
                    'servings': servings,
                    'food': logGroup[1],
                    'cals': totalCals
                }

                newTimeList.append(dix)

            # set in the new day dix
            newDayDix[timeKey] = newTimeList

        # set the new day key
        newHistory[dayKey] = newDayDix;

        # save it to the file
        SaveFile(newHistory, f"{FLS}/History/foodHistory.json", overwrite=True)


#---------------------------------------------------------------------------------------------------------------------------------
# BARCODES #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------

def BarcodeSearch():
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def GetBarcode():
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def EditBarcode():
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def RemoveBarcode():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
# PRESETS #---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------
def RemovePreset():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
def GetPreset(): # Get Preset
    pass
#---------------------------------------------------------------------------------------------------------------------------------

def MakePreset(): # Make Preset
    pass
#---------------------------------------------------------------------------------------------------------------------------------

def EditPreset(): # Edit Preset
    pass

#---------------------------------------------------------------------------------------------------------------------------------
def RemovePreset():
    pass

#---------------------------------------------------------------------------------------------------------------------------------
# MISC #---------------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------------

def BulkEntry(): # Bulk Entry
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def FoodsList(): # Foods List
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def GetRecent(): # "Get Recent"
    file = GetFile(f"{FLS}/Recents/recents.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = file
    else:
        IFRESULT = '{ "order": [], "foodInfo": {}}'
    dix = Dictionary(IFRESULT)

    order = dix['order']
    foodInfo = dix['foodInfo']

    if Count(order) == 0:
        Alert("There are no recent items")
        return None

    # get the items
    for foodId in order:
        foodName = foodInfo[foodId]
                    .GetDictionaryValue('foodname')

        text = f'''
            BEGIN:VCARD
            VERSION:3.0
            N;CHARSET=UTF-8: {foodName}
            NOTE;CHARSET=UTF-8:{foodId}
            END:VCARD
        '''
        REPEATRESULTS.append(text)

    contacts = Text(REPEATRESULTS)
                .SetName('vcard.vcf')
                .GetContactsFromInput()

    chosen = ChooseFrom(contacts, prompt="Select Recent Food")

    curInfo = foodInfo[chosen.Notes]
    foodFile = curInfo['filename']

    file = GetFile(f"{FLS}/Recents/Foods/{foodFile}.json")
    return Dictionary(file)


#---------------------------------------------------------------------------------------------------------------------------------

def AddRecent():
    food = Dictionary(ShortcutInput)

    nutrDix = Dictionary(run("NutrDix"))
    
    maxRecents = 70


    if food['id'] is not None:
        IFRESULT = food['id']
    else:
        IFRESULT = RunShorctut(nutrDix['GFID'])
    
    foodId = IFRESULT
    foodName = food['Name']

    # get the ordered items
    file = GetFile(f"{FLS}/Recents/recents.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = file
    else:
        IFRESULT = '{ "order": [], "foodInfo": {}}'
    dix = Dictionary(IFRESULT)

    order = dix['order']
    foodInfo = dix['foodInfo']

    # if food is already in recents then we move it to the top

    # if its not already in recents then add it, check against max and delete
    res = filter(order, where=['Name' != foodId])
    order = []

    # puts food at the top
    order.append(foodId)
    order.append(res)

    # place the food in the filenames dictionary
    if foodInfo[foodId] is None:
        # generate filename from foodname 

        fileName = Text(f"{foodId}_{foodName}")
                    .ReplaceText(r'[\*\/\\><\.":\?\| ]', '_', regex=True)
                    .ToLowerCase()
        
        curInfo = {
            'foodname': foodName,
            'filename': fileName
        }

        foodInfo[foodId] = curInfo

        # save the file
        SaveFile(food, f"{FLS}/Recents/Foods/{fileName}.json")


    if Count(order) > maxRecents:
        for _ in range(Count(order)-maxRecents):
            deleteId = order.getLastItem()

            # remove from ordered list
            order = filter(order, where=['Name' != deleteId])

            curInfo = foodInfo[foodId]

            # remove the id mapping from the foodInfo dictionary
            val = f'"{foodId}":{curInfo}'

            foodInfo = Text(FoodInfo)
                        .ReplaceText(f',{val},', ',')
                        .ReplaceText(f'{val},', '')
                        .ReplaceText(f',{val}', '')
                        .ToDictionary()

            # delete the food file
            foodFile = GetFile(f"{FLS}/Recents/Foods/{curInfo['filename']}.json")
            DeleteFile(foodFile, deleteImmediately=True)

    # save dictionaries to json
    newDix = {}
    newDix['order'] = order
    newDix['foodInfo'] = foodInfo
    SaveFile(newDix, f"{FLS}/Recents/recents.json", overwrite=True)

#---------------------------------------------------------------------------------------------------------------------------------

def PortOverRecents():

    file = GetFile(f"{FLS}/Recents/recentNames.txt")
    names = SplitText(file, '\n')

    foodsDir = f"{FLS}/Recents/Foods"

    foodInfo = {}

    for name in names:
        # Add the name to list

        file = GetFile(f"{foodsDir}/{name}.json")
        if file is not None:
            food = Dictionary(file)
            foodId = food['id']

            order.append(foodId)

            fileName = Text(f"{foodId}_{foodName}")
                        .ReplaceText(r'[\*\/\\><\.":\?\| ]', '_', regex=True)
                        .ToLowerCase()

            curInfo = {
                'foodname': name,
                'filename': filename
            }

            foodInfo[foodId] = curInfo

            # rename the file to its correct file name
            file = GetFile(f"{foodsDir}/{name}.json")
            RenameFile(file, f"{filename}.json")

    newDix = {}
    newDix['order'] = order
    newDix['foodInfo'] = foodInfo
    SaveFile(newDix, f"{FLS}/Recents/recents.json", overwrite=True)



#---------------------------------------------------------------------------------------------------------------------------------
# SHARED ---------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------

def LogAlgorithm(dix): # Log Algorithm
    '''
    Update to use new backlog system
    Update to use dictionary from input
    {
        'Date':..
        'Food':...
    }
    '''

    '''
    Changelist:
    - Removed contin
    '''

    TRUE = 1
    FALSE = 0

    nutrDix = Dictionary(run("NutrDix"))

    res = Dictionary(ShortcutInput)

    loggingDate = Date(res['Date'])
    foodDix = Dictionary(res['Food'])

    foodName = foodDix['Name']
    servingSize = foodDix['Serving Size']

    dixValue = foodDix['Servings']
    if res is None:
        IFRESULT = AskForInput(Input.Number, prompt=f"How many servings? (1 serving = {servingSize})",
                    default=1, allowDecimals=True, allowNegatives=True)
    else:
        IFRESULT = GetNumbers(dixValue)

    # set servings in food dictionary
    mulitplier = IFRESULT
    foodDix['Servings'] = multiplier
    foodDix = run(nutrDix["Correct Dictionary"], input=foodDix)
    servings = Number(foodDix['Servings'])


    # get health app environment var
    dix = Dictionary(GetFile(f"{FLS}/Other/env.json"))
    hasHelathApp = dix['HasHealthApp']

    # add to backlog and exit if we are not on a device with a health app
    if hasHealthApp == FALSE:
        Notification(
            "Food will be logged when next on iPhone",
            title=f'{foodName} Has Been Added to Backlog',
        )

        # get the backlog file 
        file = GetFile(f"{FLS}/Other/backlog.json", noErrors=True)

        if file is not None:
            IFRESULT = Dictionary(file)
        else:
            IFRESULT = { 'backlog': [] }

        backlog = IFRESULT['backlog']

        dix = {
            'Date': Text(loggingDate),
            'Food': Text(foodDix)
        }
        backlog.append(dix)

        # add it to list

        # save file
        dix = { 'backlog': backlog }
        SaveFile(dix, f"{FLS}/Other/backlog.json", overwrite=True)

        return foodDix


    # comment set of nutrients logged by the system
    text = "Protein",
          "Trans",
          "Cholesterol",
          "Sugar",
          "Monounsaturated",
          "Polyunsaturated",
          "Fat",
          "Fiber",
          "VitC",
          "Calories",
          "Iron",
          "VitA",
          "Potassium",
          "Saturated",
          "Sodium",
          "Calcium",
          "Carbs",

    nutrients = Dictionary()

    # store the nutrients in the dictionary
    for item in SplitText(text, ByNewLines):
        num = GetNumbers(foodDix[item])
        foodDix[item] = RoundNumber(num, hundredths)
        if num > 0:
            num = num * servings
            num = Round(num, "hundredths")
            nutrients[item] = num

    # now just go through each nutrient and add them 
    if nutrients["Carbs"] is not None:
        LogHealthSample("Carbohydrates", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Fiber"] is not None:
        LogHealthSample("Fiber", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Sugar"] is not None:
        LogHealthSample("Dietary Sugar", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Fat"] is not None:
        LogHealthSample("Total Fat", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Polyunsaturated"] is not None:
        LogHealthSample("Polyunsaturated Fat", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Monounsaturated"] is not None:
        LogHealthSample("Monounsaturated Fat", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Saturated"] is not None:
        LogHealthSample("Saturated Fat", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Protein"] is not None:
        LogHealthSample("Protein", nutrients[@aboveKey], "g", loggingDate)

    if nutrients["Sodium"] is not None:
        LogHealthSample("Sodium", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["Potassium"] is not None:
        LogHealthSample("Potassium", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["Cholesterol"] is not None:
        LogHealthSample("Dietary Cholesterol", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["VitA"] is not None:
        LogHealthSample("Vitamin A", nutrients[@aboveKey], "mcg", loggingDate)

    if nutrients["VitC"] is not None:
        LogHealthSample("Vitamin C", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["Calcium"] is not None:
        LogHealthSample("Calcium", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["Iron"] is not None:
        LogHealthSample("Iron", nutrients[@aboveKey], "mg", loggingDate)

    if nutrients["Calories"] is not None:
        LogHealthSample("Dietary Energy", nutrients[@aboveKey], "kcal", loggingDate)

    Notification(
        f'{foodName} has been logged to your meals',
        title='Yummy!'
    )

    # make logging experience fast by logging to cache instead of bigger dictionary
    # cache is cleared in main nutrition function

    dateKey = loggingDate.format(date="short", time=None)
    timeKey = loggingDate.format(date=None, time="short")
    cals = RoundNumber(nutrients['Calories'], ones)

    # check if cache file exists and make one by default if not available
    file = GetFile(f"{FLS}/History/foodHistoryCache.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = Text(file)
    else:
        IFRESULT = "{ 'cache': [] }"

    res = Dictionary(IFRESULT)
    cache = res['cache']

    # put the item in the cache
    dix = {
        'date' : dateKey,
        'time' :  timeKey,
        'food' : foodName,
        'servings': servings,
        'cals': cals
    }
    cache.append(dix)

    dix = {
        'cache' : cache
    }

    # save cache away for later
    SaveFile(dix, f"{FLS}/History/foodHistoryCache.json", overwrite=True)


    # TODO in Main: Check and empty food history cache


    return foodDix


#---------------------------------------------------------------------------------------------------------------------------------

def DisplayFoodItem():
    pass

#---------------------------------------------------------------------------------------------------------------------------------

def SearchAlgorithm():
    TRUE = 1
    FALSE = 0

    NutriDix = Dictionary(RunShorctut( "NutriDix" ))

    # vcard base64 photo icons
    servingSizeIcon = # ... , see servingSizeIcon.txt
    forwardIcon = # forwardIcon.txt
    backwardIcon = # backwardIcon.txt
    searchIcon = # searchIcon.txt


    resCount = 7
    searchExit = FALSE
    pageNo = 1


    query = AskForInput(Input.Text, prompt="What Food/Drink?")

    for _ in range (50):
        if searchExit == FALSE:
            searchItems = {}

            # make the query and savethe items
            url = URL(f"https://api.myfitnesspal.com/public/nutrition?q={query}&page={pageNo}&per_page={noSearchResults}")
            res = Dictionary(GetContentsOfURL(URL))

            for repeatItem in res['items']:
                # cache the item away using its id
                item = repeatItem['item']
                itemId = item['id']
                searchItems[ itemId ] = item

                # construct the vcard 
                sizes = item['serving_sizes']
                dix = sizes.atIndex(1)

                num = Number(dix['value'])
                servingSize = f"{num} {dix['unit']}"

                if Count(sizes) > 1:
                    servingSize = f"{servingSize} (and more serving sizes)"


                if item['brand_name'] is not None:
                    IFRESULT=f"{item['brand_name']} | {servingSize}"
                else:
                    IFRESULT = f"{servingSize}"
                subtitle = IFRESULT
                
                text = f'''
                BEGIN:VCARD
                VERSION:3.0
                N;CHARSET=UTF-8:{item['description']}
                ORG;CHARSET=UTF-8:{subtitle}
                NOTE;CHARSET=UTF-8:{itemId}
                END:VCARD
                '''
                
                REPEATRESULTS.append(text)
            itemCards = REPEATRESULTS

            # we need to create the vcards for next and previous
            nextPage = pageNo+1
            prevPage = nextPage-2

            text = f'''
                {itemCards}

                BEGIN:VCARD
                VERSION:3.0
                N;CHARSET=utf-8: Next Page
                ORG: Page {nextPage}
                {forwardIcon}
                END:VCARD

                BEGIN:VCARD
                VERSION:3.0
                N;CHARSET=utf-8: Previous Page
                ORG: Page {prevPage}
                {backwardIcon}
                END:VCARD

                BEGIN:VCARD
                VERSION:3.0
                N;CHARSET=utf-8: New Search
                ORG: Try a different query
                {searchIcon}
                END:VCARD
            '''

            renamedItem = SetName(text, 'vcard.vcf')
            contacts = GetContacts(renamedItem)

            chosenItem = ChooseFrom(contacts, prompt=f'"{query}" Search Results | Page {pageNo}')
            isControlItem = FALSE

            if chosenItem.Name == 'Next Page':
                isControlItem = TRUE
                pageNo = pageNo + 1

            if chosenItem.Name == 'Prev Page':
                isControlItem = TRUE
                pageNo = pageNo - 1
                if pageNo == 0:
                    Alert("This is the first page of the search!")
                    pageNo = pageNo + 1

            if chosenItem.Name == 'New Search':
                isControlItem = TRUE
                res = RunShorctut(NutriDix['Search Algorithm'])
                return res
            
            if isControlItem == FALSE:
                # then its not a control item
                itemId = chosenItem.Notes
                item = searchItems[ itemId ]

                # ask the user what serving size they want
                # first accumulate serving size information

                baseCal = item['nutritional_contents.energy.value']

                for repeatItem in item['serving_sizes']:
                    curSize = Dictionary(repeatItem)
                    servingVal = Number(curSize['value'])
                    num = baseCal * curSize['nutrition_multiplier']
                    sizeCal = RoundNumber(num, hundredths)

                    # create the vcard
                    text = f'''
                        BEGIN:VCARD
                        VERSION:3.0
                        N;CHARSET=UTF-8:{servingVal} {curSize['unit']}
                        ORG;CHARSET=UTF-8:{sizeCal}
                        NOTE;CHARSET=UTF-8:{curSize['nutrition_multiplier']}
                        {servingSizeIcon}
                        END:VCARD
                        '''
                    REPEATRESULTS.append(text)

                # append a back button to make sure they are fine
                text = f'''
                    {REPEATRESULTS}
                    BEGIN:VCARD
                    VERSION:3.0
                    N;CHARSET=UTF-8:Back
                    ORG;CHARSET=UTF-8:Go Back To Search
                    {backwardIcon}
                    END:VCARD
                    '''
                # choose from it
                renamedItem = SetName(text, 'vcard.vcf')
                contacts = GetContacts(renamedItem)

                chosenSize = ChooseFrom(contacts, prompt="Which Serving Size?")

                if chosenSize.Name != "Back"
                    # we have the users food now we just need to create it
                    # aggregate the needed information and send it out
                    searchExit = TRUE
                    selectedItem = item
                    selectedServingSize = Text(chosenSize.Name)
                    multiplier = Number(chosenSize.Notes)

    # outside of search create the food dictionary
    # first convert to our food dictionary format using the values

    # Check for illegal characters in 
    name = ReplaceText(item['description'], r'[\*\/\\><\.":\?\|]', '-', regex=True)

    # used to generate id for shortcut
    res = RunShorctut(NutriDix['GFID'])

    outputFood = {
        # that special dictionary that has all the values
        # set Calories to item['nutritional_contents.energy.value']
        # set serving size to selectedServingSize 
        # set name to name
        # set id to res
    }

    # vitamins are inputted as percentages, change them to exact values
    # source https://www.canada.ca/en/health-canada/services/understanding-food-labels/percent-daily-value.html
    vitDix = {
        'VitA': 1000,
        'VitC': 65,
        'VitD': 1100,
        'Iron': 14
    }

    for item in vitDix.keys():
        # this gives us the percentage
        num = outputFood[item] * 2
        # fractional value
        num = num / 100
        # the actual value
        num = num * vitDix[item]

        # write in the dictionary
        outputFood[item] = num

    # apply servings multiplier on nutrients
    text = "Protein",
          "Trans",
          "Cholesterol",
          "Sugar",
          "Monounsaturated",
          "Polyunsaturated",
          "Fat",
          "Fiber",
          "VitC",
          "Calories",
          "Iron",
          "VitA",
          "Potassium",
          "Saturated",
          "Sodium",
          "Calcium",
          "Carbs",

    nutrients = SplitText(text, '\n')
    for item in nutrients:
        num = outputFood[item] * multiplier
        num = RoundNumber(num, hundredths)
        outputFood[item] = num

    return outputFood

#---------------------------------------------------------------------------------------------------------------------------------

def NutriDix():
    return ;;

#---------------------------------------------------------------------------------------------------------------------------------

def SaveEnvVars(Dictionary(newVars)):
    # get the environment file
    # NOT DONE: SAVE TO ENVIRONMENT FILE SO SYSTEM HAS ACCESS TO IT
    GetFile(f"{FLS}/Other/env.json", noError=True)
    if file is not None:
        IFRESULT = Dictionary(file)
    else:
        IFRESULT = Dictionary()

    env = IFRESULT

    # overwrite keys
    for key in newVars.keys:
        env[key] = newVars[key]

    # save to file
    text = f"{env}"
    SaveFile(text, f"{FLS}/Other/env.json", overwrite=True)

#---------------------------------------------------------------------------------------------------------------------------------

def Nutrition():
    TRUE = 1
    FALSE = 0

    checkForUpdates = TRUE
    # user manually wants to clear backlog 
    reqBacklogClear = FALSE

    # load names of the shortcuts
    res = GetFile(f"{FLS}/Other/shortcutDix.txt")
    shortcutNames = Dictionary(res)

    # if device does not have health app then we will be adding to backlog
    hasHealthApp = FALSE
    if GetDeviceDetails("Model") == 'iPhone':
        hasHealthApp = TRUE

    # save the state of the health app to environment
    dix = { 'HasHealthApp': hasHealthApp }
    run(shortcutNames["Save Env Vars"], input=dix)


    # get backlog if it exists
    itemsInBacklog = FALSE
    file = GetFile(f"{FLS}/Other/backlog.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = Text(file)
    else:
        IFRESULT = "{ 'backlog': [] }"

    res = Dictionary(IFRESULT)
    backlog = res['backlog']

    if Count(backlog) > 0:
        itemsInBacklog = TRUE


    itemsInHistCache = FALSE
    runHistAfterClear = FALSE
    file = GetFile(f"{FLS}/History/foodHistoryCache.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = Text(file)
    else:
        IFRESULT = "{ 'cache': [] }"

    res = Dictionary(IFRESULT)
    histCache = res['cache']

    if Count(histCache) > 0:
        itemsInHistCache = TRUE


    if hasHealthApp == FALSE:
        text = f"Foods logged on {deviceModel} will be added to backlog"

    else:
        calsToday = 0


        healthSamples = HealthApp.Find(
                AllHealthSamples,
                whereAllAreTrue=[
                    Type="Dietary Energy",
                    StartDate=Today,
                ],
                Unit=cal
            )


        for sample in healthSamples:
            calsToday = Health.Sample.GetDetails(sample, "Value") + calsToday

        calsToday = Round (calsToday, "hundredths")

        IFRESULT = f"You've eaten {Ks} Calories Today."

    Prompt = IFRESULT

    mainMenu = Menu(prompt=prompt, options=[
            "Quick Log",
            "Log Foods",
            "Log Foods In Bulk",
            "Search and View",
            "Presets",
            "Barcodes",
            "Recent Meals",
            "Weekly Summary",
            "Food History",
            "Clear Backlog",
        ])

    if mainMenu.opt("Quick Log"):
        # InRecents does not exist!
        for item in run(shortcutNames["Get Recent"], input=InRecents):
            CurFood = item
            text = f"How many servings of {CurFood['Name']}\n(1 serving = {CurFood['Serving Size']})"
            
            # translates to set dictionary value in CurFood and then set dictionary
            CurFood['Servings'] = AskForInput(text, Input.Number, default=1, allowDecimalNumbers=True, allowNegativeNumbers=True)

            dix = {
                'Date': str(Date.CurrentDate)
                'Food': dix(CurFood)
            }
            LogList.append(dix)

        for item in LogList:
            run(shortcutNames["Log Algorithm"], input=item)

        return

    elif mainMenu.opt("Log Foods"):
        if GetDeviceDetails("Model") == 'iPhone':
            # action will be discontinued in later versions
            ContinueInShortcutsApp()

        LoggedFoodsDix = {
            'SAMPLE' : 'SAMPLE'
        }

        Dating = AskForInput("What date and time? Click Done for Right Now", Input.DateAndTime)


        for item in run(shortcutNames["Foods List"]):
            CurFood = item
            dix = {
                'Date': str(Dating)
                'Food': dix(CurFood)
            }

            CurLoggedFood = run(shortcutNames["Log Algorithm"], input=dix)
            
            # Comment: Get the logged food dictionary and add it into the logged foods dix,
            # with key: servings of food and value: food dictionary

            roundedNumber = Round(Number(CurLoggedFood['Servings']), "Hundredths")
            LoggedFoodsDix[ f"{roundedNumber}x{CurLoggedFood['name']}" ] = CurLoggedFood


        makePresetMenu = Menu(prompt="Make Preset?", options=["Yes", "No"])

        if makePresetMenu.opt("Yes"):
            # Get the keys from the logged foods dix so users can select what foods they want to make into a preset
            res = Filter( 
                SplitText(Text(LoggedFoodsDix.Keys)), 
                where=[
                    "Name" is not "SAMPLE",
                ])

            chosenItems = ChooseFrom(res, prompt="Select Foods For Preset", selectMultiple=True)

            for item in chosenItems:
                # With each chosen key we use the key to retrieve the value from logged food dix
                # and add it to the list of foods to be made into a preset (chosenFoods)
                # each item in this case are the keys from the loggedfoodsdix
                ChosenFoods.Append( LoggedFoodsDix[item] )

            # run shortcutNames[make preset ]with chosen foods
            run(shortcutNames["Make Preset"], input=ChosenFoods)

        elif makePresetMenu.opt("No"):
            pass

    elif mainMenu.opt("Log Foods In Bulk"):
        if GetDeviceDetails("Model") == 'iPhone':
            # action will be discontinued in later versions
            ContinueInShortcutsApp()

        run(shortcutNames["Bulk Entry"])

    elif mainMenu.opt("Search and View"):
        # run shortcutNames[search algorithm ]and display food with 

        searchResult = run(shortcutNames["Display Food Item"], input=run(shortcutNames["Search Algorithm"]))

        postSearchMenu = Menu(["Log Entry", "Make Preset", "Exit"])

        if postSearchMenu.opt("Log Entry"):
            date = AskForInput("Date:", Input.DateAndTime, default=Date.CurrentDate)

            dix = {
                'Date': str(date)
                'Food': dix(searchResult)
            }
            res = run(shortcutNames[
                "Log Algorithm"],
                input=dix)

            LoggedFoods2 = res

            svp = Menu(["Yes", "No"], prompt="Save As Preset?")

            if svp.opt("Yes"):
                RunShorctut("Make Preset", input=LoggedFoods2)
            if svp.opt("No"):
                pass

        elif postSearchMenu.opt("Make Preset"):
            run(shortcutNames["Make Preset"], input=searchResult)

        elif postSearchMenu.opt("Exit"):
            pass

    elif mainMenu.opt("Presets"):

        prm = Menu(prompt="Presets", options=["View Presets", "Make Preset", "Edit Preset", "Remove Preset(s)"])

        if prm.opt("View Presets"):
            res = run(shortcutNames["Get Preset"])
            for repeatItem in res:
                run(shortcutNames["Display Food Item"], input=repeatItem)

        elif prm.opt("Make Preset"):
            # run shortcutNames[foods list ]to get list of foods to be made into a preset
            res = run(shortcutNames["Foods List"])

            for item in res:
                curFood = item
                loggedFoods3.append(curFood)

            run(shortcutNames["Make Preset"], loggedFoods3)


        elif prm.opt("Edit Preset"):
            run(shortcutNames["Edit Preset"])


        elif prm.opt("Remove Preset(s)"):
            # retrieve preset names, let user choose preset then retrieve food dix and delete it by runnshortcutNames[ing remove ]preset
            file = GetFile(f"{FLS}/Presets/presetNames.txt")
            res = SplitText(file, SplitText.ByNewLines)
            
            presetsToBeDeleted = ChooseFrom(res, selectMultiple=True)

            ShowAlert("Do You Want To Continue?", title="Presets About to Be Deleted", showCancel=True)

            for item in presetsToBeDeleted:
                file = GetFile(f"{FLS}/Presets/Foods/{item}.txt")
                text = file.read()
                run(shortcutNames["Remove Preset"], text)

    elif mainMenu.opt("Barcodes"):
        brm = Menu(prompt="Barcodes", options=[
            "View Personal Database",
            "Add to Personal Database",
            "Edit Items in Personal Database",
            "Remove From Personal Database"
            ])


        if brm.opt("View Personal Database"):
            res = run(shortcutNames["Get Barcode"])
            for item in res:
                run(shortcutNames["Display Food Item"], input=item)

        elif brm.opt("Add to Personal Database"):
            run(shortcutNames["Barcode Search"])

        elif brm.opt("Edit Items in Personal Database"):
            run(shortcutNames["Edit Barcode"])

        elif brm.opt("Remove From Personal Database"):
            res = run(shortcutNames["Get Barcode"])
            run(shortcutNames["Remove Barcode"], input=res)
        

    elif mainMenu.opt("Recent Meals"):
        res = run(shortcutNames["Get Recent"])
        for item in res:
            run(shortcutNames["Display Food Item"], input=item)


    elif mainMenu.opt("Weekly Summary"):
        run(shortcutNames["Week Summary"])


    elif mainMenu.opt("Food History"):
            if itemsInBacklog == TRUE:
                ShowAlert("There are items in the backlog, food history will not be accurate until backlog is cleared", showCancel=True)
            
            
            if itemsInHistCache == TRUE:
                    runHistAfterClear = TRUE
                else:
                    run(shortcutNames["Food History"])

    elif mainMenu.opt("Clear Backlog"):
        reqBacklogClear = TRUE


    # clearing the backlog
    if hasHealthApp == TRUE:

        if itemsInBacklog == TRUE:
            # clear items by logging them
            for item in backlog:
                run(shortcutNames["Log Algorithm"], input=item)

            # erase the backlog
            Delete(f"{FLS}/Other/backlog.json", deleteImmediately=True)

        else:
            if reqBacklogClear == TRUE:
                # if user req clear backlog let them no there was nothing to clear
                ShowAlert("There are no foods in the backlog")


    # clear the cache
    file = GetFile(f"{FLS}/History/foodHistoryCache.json", errorIfNotFound=False)
    if file is not None:
        IFRESULT = Text(file)
    else:
        IFRESULT = "{ 'cache': [] }"
    res = Dictionary(IFRESULT)
    histCache = res['cache']

    if Count(histCache) > 0:

        file = OpenFile(f"{FLS}/History/foodHistory.json", errorIfNotFound=False)
        if file is not None:
            IFRESULT = file
        else:
            IFRESULT = {}
        history = Dictionary( IFRESULT )


        for item in histCache:
            dayKey = item['date']
            timeKey = item['time']

            dayDix = history[dayKey]
            if history[dayKey] is None:
                IFRESULT = history[dayKey]
            else
                IFRESULT = {}
            dayDix = IFRESULT

            timeList = dayDix[timeKey]

            timeList.append({
                    'food': item['food'],
                    'servings': item['servings'],
                    'cals': item['cals']
                })

            dayDix[timeKey] = timeList
            history[dayKey] = dayDix

        # save our history
        SaveFile(history, f"{FLS}/History/foodHistory.json", overwrite=True)

        # clear our cache by deleting the file
        Delete(f"{FLS}/History/foodHistoryCache.json", deleteImmediately=True)

    if runHistAfterClear == TRUE:
        run(shortcutNames["Food History"])


    if checkForUpdates == TRUE:
        run(shortcutNames["NutriDix Updater"])




